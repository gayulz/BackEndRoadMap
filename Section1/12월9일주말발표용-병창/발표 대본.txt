HTTP란 HTTP(Hyper Text Transfer Protocol를 줄인 말로, 
Hypter Text는 문서나 정보가 다른 문서와 연결되어 있는 텍스트 를 의미합니다. /

이는 웹 페이지에서 하이퍼링크를 통해 서로 다른 페이지로 이동할 수 있는 기능을 나타냅니다./

"Transfer"는 데이터가 어떤 형식으로 전송되는지를 나타냅니다/

 HTTP는 클라이언트(일반적으로 웹 브라우저)와 서버 간에 데이터를 주고받는 프로토콜로, 클라이언트가 서버에 요청을 보내고, 서버가 그에 대한 응답을 제공하는 방식으로 동작합니다./

"Protocol"은 컴퓨터 간에 통신하기 위해 정의된 규칙의 집합을 나타냅니다. /
HTTP는 웹에서 정보를 주고받기 위한 규칙을 정의한 프로토콜로, 클라이언트와 서버 간의 상호작용을 표준화합니다./

WWW, 인터넷의 기초이며 하이퍼텍스트 링크를 통해 웹 페이지를 불러오는데에 사용됩니다

HTTP는 네트워크된 기기 간 정보를 전송하기 위해 설계된 응용 계층 프로토콜로, 네트워크 프로토콜 스택의 다른 계층 위에서 실행됩니다.
무슨 뜻이냐면, HTTP는 OSI 모델에서 응용 계층에 위치한 프로토콜입니다. 응용 계층은 사용자와 직접 상호 작용하며, HTTP는 웹 브라우징과 같은 응용 프로그램에서 사용되는 프로토콜입니다. 네트워크 통신을 위해 계층화된 프로토콜의 집합을 네트워크 프로토콜 스택이라고 칭하며, 이는 HTTP가 응용 계층에서 실행되며, 하위계층에서 제공되는 서비스를 활용한다는 뜻입니다.
예를 들어, HTTP는 전송 계층의 TCP를 사용하여 신뢰성 있는 통신을 보장하고, 네트워크 계층과 데이터 링크 계층을 통해 패킷의 전달을 담당합니다.

HTTP를 통한 전형적인 흐름은 클라이언트 기기가 서버에 요청을 보내고, 서버가 그에 대한 응답 메시지를 보내는 과정을 포함합니다.

간략하게 HTTP가 어떻게 발전해왔는지에 대해 알아보겠습니다

HTTP는 1991년에 최초로 등장했고, 이때는 GET 메소드밖에 가지고 있지 않았고, 응답은 반드시 HTML이어야만 했던 아주 단순한 구조였습니다

그로부터 5년 뒤인 1996년에 HTTP/1.0이 발표되었는데요. 이전에 비해 엄청난 발전을 이룩했습니다. HTML 이외에도 이미지, 비디오 파일, 일반 텍스트 형식 또는 그외의 것들을 포함한 다양한 응답 형식을 처리할수 있게 되었고, 새로운 메서드의 추가와 함께 요청과 응답 형식이 변경된데다 헤더 및 상태 코드 추가, 다국어 지원에 캐싱, 내용 인코딩 등 많은 기능이 추가되었습니다. 

하지만 단점도 확실했는데요. 주요 단점 중 하나는 단일 연결에서 여러 요청을 처리할 수 없었습니다. 즉, 클라이언트가 서버로부터 무언가를 요청하면 새로운 TCP 연결을 열어야 했고 해당 단일 요청이 완료되면 연결이 닫혔습니다. 이게 왜 문제가 되냐면, 예시로 웹 페이지에서 10개의 이미지, 5개의 스타일시트, 5개의 자바 스크립트 파일을 불러와야 하는 경우를 가정했을 때, HTTP/1.0 에서는 각 항목마다 새로운 연결을 필요로 했었습니다. 요청을 할 때마다 연결이 열리고,  닫히고를 반복하므로  이 자체가 three handshake와 슬로 스타트 문제로 인해 성능이 심각하게 저하되었습니다

three way handshake 간략하게 설명 - 
three way handshake는 클라이언트와 서버가 응용 프로그램 데이터를 공유하기 전에 패킷을 교환하는 과정입니다.

SYN (Synchronize): - 클라이언트는 임의의 번호, 예를 들어 x를 선택하고 이를 서버로 보냅니다.
(A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는SYN_SENT 상태가 되는 것이다.)

SYN ACK (Synchronize-Acknowledge): - 서버는 클라이언트의 요청을 승인하고 ACK 패킷을 클라이언트에게 보냅니다. 이 패킷은 서버가 선택한 임의의 번호 y와 클라이언트가 보낸 번호 x+1로 이루어져 있습니다.
(B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다. 이때 B서버는 SYN_RECEIVED 상태가 된다.)


ACK(Acknowledge): - 클라이언트는 서버로부터 받은 번호 y를 증가시키고 번호 y+1로 이루어진 ACK 패킷을 다시 보냅니다.
(A클라이언트는 B서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다. 이때의 B서버 상태가 ESTABLISHED 이다.위와 같은 방식으로 통신하는것이 신뢰성 있는 연결을 맺어 준다는 TCP의 3 Way handshake 방식이다.)

three way handshake가 완료되면 클라이언트와 서버 간의 데이터 공유가 시작됩니다. 클라이언트는 마지막 ACK 패킷을 보낸 즉시 응용 프로그램 데이터를 전송할 수 있지만 서버는 요청을 완수하기 위해 ACK 패킷을 수신하기를 기다려야 합니다.

그러나 일부 HTTP/1.0 구현은 이 문제를 극복하기 위해 Connection: keep-alive라는 새로운 헤더를 도입했습니다. 이는 서버에게 "서버야, 이 연결을 닫지말고 다시 사용할 거야"라고 알려줍니다. 그러나 여전히 이것은 널리 지원되지 않았고 문제는 계속되었습니다.

HTTP는 연결이 없는(connectionless) 것 외에도 상태가 없는(stateless) 프로토콜입니다. 즉, 서버는 클라이언트에 대한 정보를 유지하지 않으므로 각 요청은 이전 요청과 관련이 없이 서버가 직접 처리해야 하는 정보를 가져와야 합니다. 이로 인해 클라이언트가 열어야 하는 연결의 수가 많아지는 문제가 발생하며, 이로 인해 불필요한 데이터가 전송되어 대역폭 사용이 증가합니다.

그리고서 3년만에 1999년에 HTTP/1.1이 출시되었으며, 이전 버전에 비해 많은 개선 사항이 있었습니다. HTTP/1.1의 주요 개선 사항은 다음과 같습니다.

새로운 HTTP 메서드 도입: PUT, PATCH, OPTIONS, DELETE가 도입되었습니다.

호스트 이름 식별: HTTP/1.0에서는 Host 헤더가 필요하지 않았지만, HTTP/1.1에서는 필수로 요구되었습니다.

지속적인 연결: HTTP/1.0에서는 연결당 하나의 요청만 가능했으며, 요청이 완료되면 연결이 닫혔습니다. 이는 성능 문제와 지연을 초래했습니다. HTTP/1.1에서는 연결이 기본적으로 닫히지 않고 유지되었으며, 여러 순차적인 요청이 가능했습니다. 연결을 닫으려면 요청에 Connection: close 헤더가 있어야 했습니다.

파이프라이닝: 클라이언트는 응답을 기다리지 않고도 동일한 연결에서 여러 요청을 서버로 보낼 수 있었습니다. 서버는 요청을 받은 순서대로 응답을 보내야 했습니다. 이를 위해 Content-Length 헤더가 있어야 했습니다.

청크 전송: 동적 콘텐츠의 경우 서버가 전송이 시작되기 전에 Content-Length를 알 수 없는 경우가 있었습니다. HTTP/1.1에서는 청크 전송(chunked encoding)을 도입하여 이 문제를 해결했습니다. 이 경우 서버는 콘텐츠를 조각 내어 전송하고 각 청크에 대한 Content-Length를 추가했습니다. 전체 전송이 완료되면 Content-Length가 0인 빈 청크를 보내 클라이언트에게 전송이 완료되었음을 알립니다. 이를 알리기 위해 서버는 Transfer-Encoding: chunked 헤더를 포함했습니다.

인증 개선: HTTP/1.1에서는 Basic 인증 외에도 Digest 및 프록시 인증이 도입되었습니다.

캐싱, 바이트 범위, 문자 집합, 언어 협상, 클라이언트 쿠키, 향상된 압축 지원, 새로운 상태 코드 등: HTTP/1.1은 이 외에도 여러 기능을 도입했습니다.

HTTP/1.1은 1999년에 소개되었으며 많은 해 동안 표준으로 사용되었습니다. 그러나 웹이 계속해서 변화함에 따라 웹 페이지 로딩이 예전보다 자원이 많이 소모되었습니다. 현재의 간단한 웹 페이지는 30개 이상의 연결을 열어야 할 정도로 복잡합니다. 

HTTP/1.1은 지속적인 연결을 지원하지만 한 번에 하나의 연결만 가능했습니다. HTTP/1.1은 이 문제를 해결하기 위해 파이프라이닝을 도입했지만 이로 인한 성능 문제와 헤드 오브 라인 차단 등의 이슈가 여전히 존재했습니다. HTTP/1.1의 이러한 한계를 극복하기 위해 개발자들은 스프라이트 시트, CSS에 인코딩된 이미지, 단일 거대한 CSS/Javascript 파일, 도메인 샤딩 등의 해결책을 적용하기 시작했습니다.

HTTP/2는 HTTP 프로토콜의 새로운 개정판이 필요한 이유를 낮은 대기 시간으로 콘텐츠를 전송하기 위해 설계되었습니다. 이것의 주요 기능 또는 HTTP/1.1과의 차이점은 다음과 같습니다.

이진 프로토콜

HTTP/2는 HTTP/1.x에서 나타난 증가된 대기 시간 문제를 이진 프로토콜로 해결하려고 합니다. Binary 프로토콜이기 때문에 해석이 쉽지만 HTTP/1.x와는 달리 사람이 읽을 수 없습니다.
멀티플렉싱

단일 연결을 통해 여러 비동기 HTTP 요청을 멀티플렉싱합니다. 이는 별도의 연결을 여는 것 없이 모든 스트림을 비동기적으로 보내고 응답함으로써 HTTP/1.x에서 발생한 head-of-line blocking 문제를 해결합니다.
헤더 압축

헤더의 중복 데이터를 줄이기 위한 헤더 압축이 도입되었습니다. 리터럴 값은 Huffman 코드를 사용하여 인코딩되며 클라이언트와 서버는 헤더 테이블을 유지하고 반복되는 헤더를 생략하고 참조함으로써 대역폭 사용과 대기 시간 증가를 최소화합니다.
서버 푸시

클라이언트가 요청하지 않은 경우에도 서버가 특정 리소스를 클라이언트에게 푸시할 수 있는 기능입니다. 서버는 PUSH_PROMISE 프레임을 보내어 리소스를 푸시할 것임을 알리며 이는 푸시가 발생한 스트림과 약속된 스트림 ID를 포함합니다.
요청 우선순위

클라이언트는 HEADERS 프레임에 우선순위 정보를 포함하여 스트림을 열 수 있습니다. 나중에 클라이언트는 PRIORITY 프레임을 보내어 스트림의 우선순위를 변경할 수 있습니다.
보안

TLS를 통한 보안 여부에 대한 확장된 토론이 있었습니다. 최종적으로는 의무적으로 만들지 않기로 결정되었지만 대부분의 공급업체는 TLS를 통해 사용될 때만 HTTP/2를 지원할 것이라고 명시했습니다. TLS를 사용하면 일부 요구 사항이 있으며, 예를 들어 TLS 버전 1.2 이상이어야 하며 최소 키 크기가 있어야 합니다.

HTTP의 특징을 간략하게 알아보겠습니다
1.일반적으로 간단하며, 사람들이 읽고 이해하기 쉽도록 설계되었습니다
비록 HTTP/2에서 HTTP메세지를 프레임으로 캡슐화하면서 상당히 복잡성이 강화되었지만, 그럼에도 HTTP 메세지는  사람에 의해 읽히고 이해되기 쉬우며, 개발자들에게 더 쉬운 테스트와 새로운 이용자들에게 줄어든 복잡성을 제공합니다.

2. HTTP/1.0에서 소개된 HTTP 헤더를 통해 이 프로토콜을 쉽게 확장하고 실험할 수 있습니다. 새로운 기능은 클라이언트와 서버 간의 새로운 헤더 의미에 대한 간단한 합의로 도입될 수 있습니다.

3.HTTP는 상태는 없지만, 세션은 있습니다. 
HTTP는 상태를 저장하지 않습니다(Stateless). 동일한 연결 상에서 연속하여 전달된 두 개의 요청 사이에는 연결고리가 없습니다. 
이는 e-커머스 쇼핑 바구니처럼, 일관된 방식으로 사용자가 페이지와 상호작용하길 원할 때 문제가 됩니다. 하지만, HTTP의 핵심은 상태가 없는 것이지만 HTTP 쿠키는 상태가 있는 세션을 만들도록 해줍니다. 

헤더 확장성을 사용하여, 동일한 컨텍스트 또는 동일한 상태를 공유하기 위해 각각의 요청들에 세션을 만들도록 HTTP 쿠키가 추가됩니다.

-주요 기능을 알아보겠습니다
첫번째로 캐싱이 있습니다 캐싱이란, HTTP로 문서가 캐시되는 방식을 